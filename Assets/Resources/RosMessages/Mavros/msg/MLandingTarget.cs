//Do not edit! This file was generated by Unity-ROS MessageGeneration.
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using Unity.Robotics.ROSTCPConnector.MessageGeneration;

namespace RosMessageTypes.Mavros
{
    public class MLandingTarget : Message
    {
        public const string RosMessageName = "mavros_msgs/LandingTarget";

        //  MAVLink message: LANDING_TARGET
        //  https://mavlink.io/en/messages/common.html
        public Std.MHeader header;
        // # MAV_FRAME enum
        public const byte GLOBAL = 0; //  Global coordinate frame, WGS84 coordinate system. First value / x: latitude, second value / y: longitude, third value / z: positive altitude over mean sea level (MSL)
        public const byte LOCAL_NED = 2; //  Local coordinate frame, Z-up (x: north, y: east, z: down).
        public const byte MISSION = 3; //  NOT a coordinate frame, indicates a mission command.
        public const byte GLOBAL_RELATIVE_ALT = 4; //  Global coordinate frame, WGS84 coordinate system, relative altitude over ground with respect to the home position. First value / x: latitude, second value / y: longitude, third value / z: positive altitude with 0 being at the altitude of the home location.
        public const byte LOCAL_ENU = 5; //  Local coordinate frame, Z-down (x: east, y: north, z: up)
        public const byte GLOBAL_INT = 6; //  Global coordinate frame, WGS84 coordinate system. First value / x: latitude in degrees*1.0e-7, second value / y: longitude in degrees*1.0e-7, third value / z: positive altitude over mean sea level (MSL)
        public const byte GLOBAL_RELATIVE_ALT_INT = 7; //  Global coordinate frame, WGS84 coordinate system, relative altitude over ground with respect to the home position. First value / x: latitude in degrees*10e-7, second value / y: longitude in degrees*10e-7, third value / z: positive altitude with 0 being at the altitude of the home location.
        public const byte LOCAL_OFFSET_NED = 8; //  Offset to the current local frame. Anything expressed in this frame should be added to the current local frame position.
        public const byte BODY_NED = 9; //  Setpoint in body NED frame. This makes sense if all position control is externalized - e.g. useful to command 2 m/s^2 acceleration to the right.
        public const byte BODY_OFFSET_NED = 10; //  Offset in body NED frame. This makes sense if adding setpoints to the current flight path, to avoid an obstacle - e.g. useful to command 2 m/s^2 acceleration to the east.
        public const byte GLOBAL_TERRAIN_ALT = 11; //  Global coordinate frame with above terrain level altitude. WGS84 coordinate system, relative altitude over terrain with respect to the waypoint coordinate. First value / x: latitude in degrees, second value / y: longitude in degrees, third value / z: positive altitude in meters with 0 being at ground level in terrain model.
        public const byte GLOBAL_TERRAIN_ALT_INT = 12; //  Global coordinate frame with above terrain level altitude. WGS84 coordinate system, relative altitude over terrain with respect to the waypoint coordinate. First value / x: latitude in degrees*10e-7, second value / y: longitude in degrees*10e-7, third value / z: positive altitude in meters with 0 being at ground level in terrain model.
        // # LANDING_TARGET_TYPE enum
        public const byte LIGHT_BEACON = 0; //  Landing target signaled by light beacon (ex: IR-LOCK)
        public const byte RADIO_BEACON = 1; //  Landing target signaled by radio beacon (ex: ILS, NDB)
        public const byte VISION_FIDUCIAL = 2; //  Landing target represented by a fiducial marker (ex: ARTag)
        public const byte VISION_OTHER = 3; //  Landing target represented by a pre-defined visual shape/feature (ex: X-marker, H-marker, square)
        public byte target_num;
        public byte frame;
        public float[] angle;
        public float distance;
        public float[] size;
        public Geometry.MPose pose;
        public byte type;

        public MLandingTarget()
        {
            this.header = new Std.MHeader();
            this.target_num = 0;
            this.frame = 0;
            this.angle = new float[2];
            this.distance = 0.0f;
            this.size = new float[2];
            this.pose = new Geometry.MPose();
            this.type = 0;
        }

        public MLandingTarget(Std.MHeader header, byte target_num, byte frame, float[] angle, float distance, float[] size, Geometry.MPose pose, byte type)
        {
            this.header = header;
            this.target_num = target_num;
            this.frame = frame;
            this.angle = angle;
            this.distance = distance;
            this.size = size;
            this.pose = pose;
            this.type = type;
        }
        public override List<byte[]> SerializationStatements()
        {
            var listOfSerializations = new List<byte[]>();
            listOfSerializations.AddRange(header.SerializationStatements());
            listOfSerializations.Add(new[]{this.target_num});
            listOfSerializations.Add(new[]{this.frame});
            
            Array.Resize(ref angle, 2);
            foreach(var entry in angle)
                listOfSerializations.Add(BitConverter.GetBytes(entry));
            listOfSerializations.Add(BitConverter.GetBytes(this.distance));
            
            Array.Resize(ref size, 2);
            foreach(var entry in size)
                listOfSerializations.Add(BitConverter.GetBytes(entry));
            listOfSerializations.AddRange(pose.SerializationStatements());
            listOfSerializations.Add(new[]{this.type});

            return listOfSerializations;
        }

        public override int Deserialize(byte[] data, int offset)
        {
            offset = this.header.Deserialize(data, offset);
            this.target_num = data[offset];;
            offset += 1;
            this.frame = data[offset];;
            offset += 1;
            
            this.angle= new float[2];
            for(var i = 0; i < 2; i++)
            {
                this.angle[i] = BitConverter.ToSingle(data, offset);
                offset += 4;
            }
            this.distance = BitConverter.ToSingle(data, offset);
            offset += 4;
            
            this.size= new float[2];
            for(var i = 0; i < 2; i++)
            {
                this.size[i] = BitConverter.ToSingle(data, offset);
                offset += 4;
            }
            offset = this.pose.Deserialize(data, offset);
            this.type = data[offset];;
            offset += 1;

            return offset;
        }

        public override string ToString()
        {
            return "MLandingTarget: " +
            "\nheader: " + header.ToString() +
            "\ntarget_num: " + target_num.ToString() +
            "\nframe: " + frame.ToString() +
            "\nangle: " + System.String.Join(", ", angle.ToList()) +
            "\ndistance: " + distance.ToString() +
            "\nsize: " + System.String.Join(", ", size.ToList()) +
            "\npose: " + pose.ToString() +
            "\ntype: " + type.ToString();
        }
    }
}
